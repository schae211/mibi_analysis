---
title: "Exploratory Data Analysis MiBi"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
---

# Set up

Messages will be hidden and the output collapsed to make the Rmd more clear.

```{r setup}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, message = FALSE)
knitr::opts_knit$set(root.dir = "~/Saez/workflowr_projects/mibi_analysis/")
```

Loaded Packages.

```{r}
library(mistyR)
library(future)
plan("multisession", workers=14)
library(tidyverse)
library("factoextra")
```

# Loading and Processing Data

```{r}
input <- read_csv("data/cellData.csv")

# See description in Readme
group.trans <- c("1" = "Unidentified", "2" = "Immune", "3" = "Endothelial", 
                 "4" = "Mesenchymal-like", "5" = "Tumor", 
                 "6" = "Keratin-positive tumor")

immune.group.trans <- c("0" = "Non-Immune?", "1" = "Tregs", "2" = "CD4 T", "3" = "CD8 T", 
                        "4" = "CD3 T", "5" = "NK", "6" = "B",
                        "7" = "Neutrophils", "8" = "Macrophages", 
                        "9" = "DC", "10" = "DC/Mono", "11" = "Mono/Neu", 
                        "12" = "Other immune")

raw_data <- input %>%
  mutate(Group = group.trans[as.character(Group)]) %>%
  mutate(immuneGroup = immune.group.trans[as.character(immuneGroup)])
  
raw_data %>% slice_head(n=6)
```

Add coordinates of the cells.

Doing it in R takes quite some time but offers more control that the 
[center of mass function in scipy](https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html)

```{r}
if ("alternative_coordinates.RDS" %in% list.files("data")) {
  alternative.coord <- readRDS("data/alternative_coordinates.RDS")
} else {
  library(tiff)
  lbs <- c(1:29, 31:41)
  alternative.coord <- furrr::future_map_dfr(lbs, function(id) {
    print(id)
    # Read in raw matrix (in tiff format)
    tiff <- readTIFF(paste0("/home/philipp/data/saez/p", id, "_labeledcellData.tiff"),
                     as.is = TRUE)
    seq.rows <- seq_len(nrow(tiff))
    seq.cols <- seq_len(ncol(tiff))
    # important: map over all unique values here! (but I removed 1 and 2)
    cell.ids <- unique(as.vector(tiff))[-which(unique(as.vector(tiff)) %in% c(0,1))]
    map_dfr(cell.ids, function(i) {
      if (i %% 100 == 0) print(i)
      # Convert to binary matrix with TRUE and FALSE
      binary <- (tiff == i)
      s <- sum(binary)
      # Calculate center of mass
      c(id = id, 
        i = i,
        x.center = sum(seq.rows * rowSums(binary)) / s,
        y.center = sum(seq.cols * colSums(binary)) / s
      )
    })
  })
  saveRDS(alternative.coord, file = "data/alternative_coordinates.RDS")
}
```

Join the coordinates with the meta data.

```{r}
data <- raw_data %>%
  inner_join(alternative.coord, by = c("SampleID" = "id", 
                                       "cellLabelInImage" = "i")) %>%
  rename(row = x.center, col = y.center)
```

Diving into sample 40. Let's check which cell IDs where in the tiff 
but not in the meta data. Maybe those spots turned out not be cells 
in the end (segmentation errors?).

```{r}
dplyr::setdiff(
  alternative.coord %>% filter(id == 40) %>% pull(i),
  data %>% filter(SampleID == 40) %>% pull(cellLabelInImage)
  ) %>%
  length()
```

Before proceeding with the analysis, check whether we have any NAs.

```{r}
stopifnot(sum(map_int(colnames(data), ~ sum(is.na(data[[.x]])))) == 0)
```


Split the data into expression matrix and meta data.

```{r}
meta <- data %>%
  select(c(1:3, 53:59))
meta %>% slice_head(n=6)

expr <- data %>%
  select(4:52)
expr %>% slice_head(n=6)
```

# Metadata

Number of cells per sample. Curiously there is not sample 30.

```{r}
meta %>%
  count(SampleID) %>%
  ggplot() +
  geom_bar(aes(x=SampleID, y=n), stat = "identity")
```

Number of "cell types" over all samples as annotated by the authors or the
study. We mostly have tumor and immune cells. Keratin serves as a marker
for cancer cells.

```{r}
meta %>%
  count(Group) %>%
  arrange(desc(n))
```

Patient data

```{r}
patient.info <- read_csv("data/patient_class.csv",
                         col_names = c("SampleID", "Classification"))
patient.info %>% slice_head(n=6)
```

How were the cells actually classified?

When looking at the first two principal components, we see quite a clear
distinction though the first plot suffers from overplotting. Plotting only
2 percent of the points makes things a little bit better.

```{r}
pca <- stats::prcomp(expr)
ggplot() +
  geom_point(aes(x=seq_len(length(pca$sdev)), y = pca$sdev^2))
ggplot() +
  geom_point(aes(x=pca$x[,1], pca$x[,2], color = meta$Group), size = 0.1)
subs <- sample(nrow(pca$x), .02*nrow(pca$x))
ggplot() +
  geom_point(aes(x=pca$x[subs,1], pca$x[subs,2], 
                 color = meta$Group[subs]), size = 0.2)
```

Cluster the cells using the leiden algorithm? Omitting here, because
it is computiationally quite expensive.

```{r}
snn <- bluster::makeSNNGraph(pca$x[,1:20], k = 20)
clust.louvain <- igraph::cluster_louvain(snn)$membership
table(clust.louvain)
```

How are the marker distributed in the clusters?

```{r fig.width=6, fig.height=6}
# Making Psuedobulks per cluster
expr.matrix <- as.matrix(
  expr %>%
    select(- c("Background", "P", "Si", "Au", "Na", "Ca", "Ta", "dsDNA",
               "Fe"))
)
pseudobulk <- as.matrix(
  map_dfr(unique(clust.louvain), function(i) {
    colSums(expr.matrix[clust.louvain == i,])
  })
)
rownames(pseudobulk) <- unique(clust.louvain)

# Plotting Heatmap
pheatmap::pheatmap(t(pseudobulk))
```

Next we will have a closer look at the immune populations. And according
to the number of cells present, macrophages and T-cells are the major
players, followed by B-cells.

```{r}
meta %>%
  count(immuneGroup) %>%
  arrange(desc(n))
```

# Distribution of the markers

Histograms per marker over all samples. We can see that that there is a huge
variability in the expression of different markers. The measured entities 
other than proteins (Au, Background, Beta catentin, C, Ca, Fe, Si, Ta) were
later excluded from the analysis with MISTy.

```{r fig.height=12, fig.width=18}
expr %>%
  pivot_longer(cols = everything(), names_to = "marker", values_to = "expression") %>%
  ggplot() +
  geom_histogram(aes(x=expression), bins = 100) +
  facet_wrap(~ marker, scales = "free")
```

Looking at the boxplot for the expression per marker over all samples, ignoring
outliers which are defined as points which includes all points outside of 
median Â± 1.5 * IQR (interquantile range), we can again see the broad
variablity.

```{r}
expr %>%
  pivot_longer(cols = everything(), names_to = "marker", values_to = "expression") %>%
  ggplot() +
  geom_boxplot(aes(y=expression, x=marker), outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  coord_cartesian(ylim = c(-5, 5))
```

Focusing on the measured proteins, the most highly expressed species 
(according to the mean) were:

```{r}
tibble(marker = colnames(expr), mean.expression = colMeans(expr)) %>%
  filter(!(marker %in% c("Ta", "Au", "P", "Si", "C", "Na", "Ca", "Fe", 
                         "dsDNA", "Backgrond"))) %>%
  slice_max(mean.expression, n=6)
```

# Spatial Data

First, what is the scale? 1 Pixel corresponds to about 390 nm.

We will first look at the spatial data from all samples in one plot. The
cell types are annotated according to the information the authors of the 
original study provided.

As pointed out in their publication, one can see that there is a continuum 
between mixing of immune cells (yellow) and cancer tissue (green and blue).
Either we can see a clear interface between both populations or they are
totally mixed. This is actually associated with the clinical outcome.

In principle I could stratify the samples based on this phenotype (using
the same mixing score which was used in the paper, namely dividing the number
of immune-tumor interactions (direct neighbors?) by the number of immune-immune
interactions.

```{r fig.height=12, fig.width=18}
meta %>%
  ggplot() +
  geom_point(aes(x = row, y = col, col = Group), size = .1) +
  facet_wrap(~ SampleID) + 
  guides(colour = guide_legend(override.aes = list(size = 4)))
```

## Mixing Score

Calculating the mixing score by counting for all immune cells in each
sample how many contacts to they have to cancer cells divided by the 
contacts to other immune cells. The contacts are determined by
Delaunay Triangulation and cells are only considered to be neighbors
if the distance between them is below 40.

```{r}
coord.type.smp <- unique(meta$SampleID) %>%
  set_names(paste0("s", .)) %>%
  map(function(id) {
    meta %>%
      filter(meta$SampleID == id) %>% 
      select(row, col, Group) %>%
      mutate(Group = ifelse(Group == "Keratin-positive tumor", 
                            "Tumor", Group)) %>%
      filter(Group %in% c("Tumor", "Immune")) %>%
      mutate(id = seq_len(nrow(.)))
  })

# helper function for getting direct neighbors
get_neighbors <- function(ddobj, id) {
  dplyr::union(
    ddobj$delsgs$ind1[which(ddobj$delsgs$ind2 == id)],
    ddobj$delsgs$ind2[which(ddobj$delsgs$ind1 == id)]
  )
}

neighbor.thr <- 40

contacts.smp <- coord.type.smp %>%
  set_names() %>%
  map_dfr(function(smp) {
    
    delaunay <- deldir::deldir(as.data.frame(smp %>% select(row, col)))
    dists <- distances::distances(as.data.frame(smp %>% select(row, col)))
    ids.to.map <- smp %>% filter(Group == "Immune") %>% pull(id)
    
    map(ids.to.map, function(i) {
      alln <- get_neighbors(delaunay, i)
      actualn <- alln[which(dists[alln, i] <= neighbor.thr)]
      
      smp %>%
        filter(id %in% actualn) %>%
        pull(Group)
      
    }) %>% 
      unlist %>%
      table
  })

contacts.smp %>%
  mutate(sample = factor(names(coord.type.smp), 
                         levels = names(coord.type.smp))) %>%
  mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
  ggplot() +
  geom_bar(aes(x=sample, y=ratio.tumor.immune), stat="identity") +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 
```

Looking at the samples with the top mixing score.

```{r fig.width=12, fig.height=4}
contacts.smp %>%
  mutate(sample = names(coord.type.smp)) %>%
  mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
  arrange(desc(ratio.tumor.immune)) %>%
  slice_max(ratio.tumor.immune, n=6)

meta %>%
  filter(SampleID %in% c(15, 18, 22, 24)) %>%
  ggplot() +
  geom_point(aes(x = row, y = col, col = Group), size = .1) +
  facet_wrap(~ SampleID, ncol = 4) + 
  guides(colour = guide_legend(override.aes = list(size = 4)))
```

Looking at the samples with the lowest mixing score.

```{r fig.width=12, fig.height=4}
contacts.smp %>%
  mutate(sample = names(coord.type.smp)) %>%
  mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
  arrange(desc(ratio.tumor.immune)) %>%
  slice_min(ratio.tumor.immune, n=6)

meta %>%
  filter(SampleID %in% c(35, 28, 16, 37)) %>%
  ggplot() +
  geom_point(aes(x = row, y = col, col = Group), size = .1) +
  facet_wrap(~ SampleID, ncol = 4) + 
  guides(colour = guide_legend(override.aes = list(size = 4)))
```


And we can see that those mixing scores resemble exactly what we see
in the visualization.

## Close up sample 40

Looking more closely at sample 40 to make sure that the preprocessing
went right. First, we will look at the cells only using their
calculated center of mass.

```{r fig.height=6, fig.width=8}
meta %>%
  filter(SampleID == 40) %>%
  ggplot() +
  geom_point(aes(x = row, y = col, col = Group), size=.4)  + 
  guides(colour = guide_legend(override.aes = list(size = 2)))
```

And furthermore, we will look at the tiff to.

```{r fig.height=6, fig.width=8}
library(tiff)
id = 40
tiff <- readTIFF(paste0("data/raw_tiffs/p", 
                        id, "_labeledcellData.tiff"), as.is = TRUE)
```

First, the binary tiff, meaning all values that there not 0 or 1 (i.e. a
cell was detected).

```{r}
# get coordinates for where there was a cell detected (=: binary)
binary <- apply(tiff, c(1,2), function(n) !(n %in% c(0,1)))
binary.df <- as.data.frame(binary)
rownames(binary.df) <- seq_len(nrow(binary))
colnames(binary.df) <- seq_len(ncol(binary))

df <- binary.df %>% 
  rownames_to_column(var = "row") %>%
  pivot_longer(cols = !(row), names_to = "col") %>%
  mutate(row = as.numeric(row), col = as.numeric(col))

subs <- sample(nrow(df), .03 * nrow(df))

df %>%
  slice(n = subs) %>%
  mutate(cell.present = value) %>%
  ggplot() +
  geom_point(aes(x=row, y=col, col=cell.present), size=.1) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank()) +
  scale_colour_manual(values = c("TRUE" = "green2", 
                                 "FALSE" = "blue4"))  + 
  guides(colour = guide_legend(override.aes = list(size = 2)))
```

Second, we will visualize the tiff and the labeled center of mass together.
And on this scale the result actually looks quite nice.

```{r fig.height=8, fig.width=10}
s.40 <- meta %>%
  filter(SampleID == 40)

tiff.40 <- df %>%
  filter(value) %>%
  slice_sample(., n = nrow(.)/10)

ggplot() +
  geom_point(data = tiff.40, aes(x=row, y=col), col="black", 
             size = 0.1, stroke = 0, shape = 16) +
  geom_point(data = s.40, aes(x=row, y=col, col=Group), size = .5) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank())  + 
  guides(colour = guide_legend(override.aes = list(size = 2)))
```

To qualitatively assess the performance of the segmentation we will furthermore
look at a close up of sample 40, more specifically the region from row 0 to
row 600 and from col 1448 to col 2048. And we can see
that the center of mass (colored point) mostly matches the cell boundaries,
but not always! Moreover, in a second plot the cell ids were plotted.

```{r fig.height=8, fig.width=10}
c.max <- dim(binary)[1]
top_left <- list(row = 0, col = c.max)
bottom_right <- list(row = 600, col = c.max-600)

# get the unique coordinates for each cell
tiff.df <- as.data.frame(tiff)
rownames(tiff.df) <- seq_len(nrow(tiff))
colnames(tiff.df) <- seq_len(ncol(tiff))

tiff.df.plot <- tiff.df %>%
  rownames_to_column(var = "row") %>%
  pivot_longer(cols = !(row), names_to = "col") %>%
  mutate(row = as.numeric(row), col = as.numeric(col)) %>%
  filter(!(value %in% c(0, 1))) %>%
  # how to get only entry for each unique value
  group_by(value) %>%
  filter(row_number()==1) %>%
  ungroup()

s.40 <- meta %>%
  filter(SampleID == 40) %>%
  filter(row >= top_left$row, row <= bottom_right$row,
         col >= bottom_right$col, col <= top_left$col)

tiff.40 <- df %>%
  filter(value) %>%
  filter(row >= top_left$row, row <= bottom_right$row,
         col >= bottom_right$col, col <= top_left$col)

labels.40 <- tiff.df.plot %>%
  filter(row >= top_left$row, row <= bottom_right$row,
         col >= bottom_right$col, col <= top_left$col)

ggplot() +
  geom_point(data = tiff.40, aes(x=row, y=col), col="black", 
             size = 0.1, stroke = 0, shape = 16) +
  geom_point(data = s.40, aes(x=row, y=col, col=Group), size = 3) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank())

ggplot(labels.40) +
  geom_label(aes(x = row, y = col, label = value), size = 2.5)
```

# Sample Metadata

```{r}
# Generating Sample Meta Data
immune.counts <- meta %>%
  group_by(SampleID) %>%
  count(Group) %>%
  pivot_wider(names_from = Group, values_from = n,
              names_prefix = "Count.")

total.counts <- meta %>%
  count(SampleID) %>%
  rename(Count.Total = n)

mixing.score <- round(
  contacts.smp %>% 
    mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
    pull(ratio.tumor.immune),
  2)

patient.info.paper <- readxl::read_xlsx("data/mmc2.xlsx", 
                                        skip = 1, col_names = TRUE)

sample.meta <- patient.info %>%
  filter(SampleID != 30) %>%
  mutate(ratio.tumor.immune = as.vector(mixing.score)) %>%
  inner_join(immune.counts, by = "SampleID") %>%
  inner_join(total.counts, by = "SampleID") %>%
  # see paper Figure 3, Panel C
  mutate(Classification = 
         case_when(Classification == 0 ~ "mixed",
                   Classification == 1 ~ "compartimentalized",
                   Classification == 2 ~ "cold")) %>% 
  mutate(SampleID = as.character(SampleID)) %>%
  left_join(patient.info.paper, by = c("SampleID" = "InternalId"))
```

# Run MISTy on all samples

## Preparation

Select only proteins from the expression matrix and check for NAs.

Also we need to check the variance for each marker in each same and
exclude the marker if the variance is 0. The same is true for markers
whose number of unique values is lower than the desired number of cv
folds (here 10).

```{r}
cv.folds = 10
expr.smp <- unique(meta$SampleID) %>%
  set_names(paste0("s", .)) %>%
  map(function(id) {
    ret.expr <- expr %>%
      filter(meta$SampleID == id) %>%
      # Select only proteins
      select(11:47)
    
    # Check for zero variance (otherwise MISTy throws an error)
    target.var <- apply(ret.expr, 2, stats::sd, na.rm = TRUE)
    ret.expr <- ret.expr %>% select(-names(which(target.var == 0)))
    
    # Check for how many unique values
    target.unique <- colnames(ret.expr) %>%
      purrr::set_names() %>%
      purrr::map_int(~ length(unique(ret.expr %>% pull(.x))))
    ret.expr <- ret.expr %>% select(
      names(target.unique[target.unique > cv.folds])
      )
      
    colnames(ret.expr) <- make.names(colnames(ret.expr))
    ret.expr
  })

# Check NAs for sample 40
sum(map_int(names(expr.smp$s40), ~ sum(is.na(expr.smp$s40[.x]))))

coord.smp <- unique(meta$SampleID) %>%
  set_names(paste0("s", .)) %>%
  map(function(id) {
    meta %>%
      filter(meta$SampleID == id) %>% 
      select(row, col)
  })

# Check NAs for sample 40
sum(map_int(names(coord.smp$s40), ~ sum(is.na(coord.smp$s40[.x]))))

nrow(expr.smp$s40) == nrow(coord.smp$s40)
```

Looking at the pairwise distances to get a feeling for which numbers to 
plug in for generating the juxtaview and paraview.

```{r}
# helper function for nearest neighbors
dist_k_nn <- function(sample, k) {
  nn <- RANN::nn2(sample, eps=0.0, k = k)
  map_dbl(seq_len(nrow(sample)), function(n) {
    mean(nn$nn.dists[n, ])
  })
}

# helper function for getting direct neighbors
get_neighbors <- function(ddobj, id) {
  dplyr::union(
    ddobj$delsgs$ind1[which(ddobj$delsgs$ind2 == id)],
    ddobj$delsgs$ind2[which(ddobj$delsgs$ind1 == id)]
  )
}

# mean distance to the direct neighbors for each cell
mean.dists.direct.neighbors <- map(coord.smp, function(smp) {
  delaunay <- deldir::deldir(as.data.frame(smp))
  dists <- distances::distances(as.data.frame(smp))
  map_dbl(seq_len(nrow(smp)), function(id) {
    nn <- get_neighbors(delaunay, id)
    mean(dists[nn, id])
  })
}) %>% unlist

# histogram
ggplot(data.frame(dist = mean.dists.direct.neighbors)) +
  geom_histogram(aes(dist), bins = 100) +
  lims(x = c(0,100)) +
  geom_vline(xintercept = 40, col = "blue")

# summary
summary(mean.dists.direct.neighbors)

# mean distances to the 5, 10, 15, 20 nearest neighbors
neighbor.dists <- map_dfr(coord.smp, function(smp) {
  c(10, 20, 40, 80) %>%
    set_names() %>%
    map_dfc(function(k) {
  dist_k_nn(smp, k)
    }) %>%
  set_names(paste0("dist_to_", c("10", "20", "40", "80")))
})

# summary
summary(neighbor.dists)

# visualize distribution
neighbor.dists %>%
  pivot_longer(cols = everything()) %>%
  mutate(name = factor(name, levels = paste0("dist_to_", c("10", "20", "40", "80")))) %>%
  ggplot() +
  geom_histogram(aes(value), bins = 100) +
  facet_wrap(~ name) +
  lims(x = c(0, 200)) +
  geom_vline(xintercept = 120, col = "blue")
```

## Generating the MISTy views

Based on the data above, I am ging to use a neighbor threshold of 40 for
the juxtaview and a cutoff of 120 for the paraview (plus the zone of
indifference which will conclusively be 40).

```{r}
if ("misty_views_smp.RDS" %in% list.files("data")) {
  misty.views.smp <- readRDS("data/misty_views_smp.RDS")
} else {
  misty.views.smp <- map2(expr.smp, coord.smp, function(expr, coord) {
    
    # Create views and run MISTy
    create_initial_view(expr) %>%
      add_juxtaview(positions = coord, neighbor.thr = 40) %>%
      add_paraview(positions = coord, l = 120, zoi = 40)
  })
  names(misty.views.smp) <- names(expr.smp)
  saveRDS(misty.views.smp, "data/misty_views_smp.RDS")
}
```

Running with RF as ML algorithm to build the view-specific models.

```{r}
if ("ranger.results.RDS" %in% list.files("data")) {
  ranger.results <- readRDS("data/ranger.results.RDS")
} else {
  cv.folds = 10
  ranger.results.folders <- map2(
    misty.views.smp, names(misty.views.smp), function(smp, name) {
      
      smp %>% run_misty(results.folder = paste0("analysis/results/ranger_", name),
                        cv.folds = cv.folds)
    })
  ranger.results <- collect_results(ranger.results.folders)
  saveRDS(ranger.results, "data/ranger.results.RDS")
}
```

```{r}
mistyR::plot_improvement_stats(ranger.results)
```

Running with MARS as ML algorithm to build the view-specific models.

```{r}
if ("earth.results.RDS" %in% list.files("data")) {
  earth.results <- readRDS("data/earth.results.RDS")
} else {
  cv.folds = 10
  earth.results.folders <- map2(
    misty.views.smp, names(misty.views.smp), function(smp, name) {
      
      smp %>% run_misty(results.folder = paste0("analysis/results/earth_", name),
                        cv.folds = cv.folds, method = "bag", learner = "earth")
    })
  earth.results <- collect_results(earth.results.folders)
  saveRDS(earth.results, "data/earth.results.RDS")
}
```

```{r}
mistyR::plot_improvement_stats(earth.results)
```

# Comparing the results

## Improvements

```{r fig.width=10, fig.height=14}
colors <- c("earth" = "forestgreen", "ranger" = "blue1")

all.improvements <- rbind(
  ranger.results$improvements %>% mutate(method = "ranger"),
  earth.results$improvements %>% mutate(method = "earth")
)

all.improvements %>%
  filter(measure %in% c("gain.R2", "multi.R2", "intra.R2")) %>%
  mutate(measure = factor(measure, 
                          levels = c("gain.R2", "multi.R2", "intra.R2"))) %>%
  ggplot() +
  geom_boxplot(aes(x=target, y=value, col = method)) +
  facet_wrap(~ measure, ncol = 1, scales = "free") +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1),
        plot.title = element_text(hjust = 0.5),
        axis.text.x.bottom = element_text(vjust = 0.4)) +
  scale_colour_manual(values = colors)
```

## View Contributions

Random Forest (ranger):

```{r}
mistyR::plot_view_contributions(ranger.results)
```

Also looking at the variability.

```{r fig.width=6, fig.height=6}
ranger.results$contributions %>%
  filter(!str_starts(view, "p\\."), view != "intercept") %>%
  ggplot() +
  geom_boxplot(aes(x = target, y = value)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  facet_wrap(~ view, ncol = 1)
```

MARS (earth):

```{r}
mistyR::plot_view_contributions(earth.results)
```

```{r fig.width=6, fig.height=6}
earth.results$contributions %>%
  filter(!str_starts(view, "p\\."), view != "intercept") %>%
  ggplot() +
  geom_boxplot(aes(x = target, y = value)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  facet_wrap(~ view, ncol = 1)
```

## Importances

Random Forest

```{r fig.width=6, fig.height=6}
mistyR::plot_interaction_heatmap(ranger.results, view = "intra", clean = TRUE)
mistyR::plot_interaction_heatmap(ranger.results, view = "juxta.40", clean = TRUE)
mistyR::plot_interaction_heatmap(ranger.results, view = "para.120", clean = TRUE)
```

MARS

```{r fig.width=6, fig.height=6}
mistyR::plot_interaction_heatmap(earth.results, view = "intra", clean = TRUE)
mistyR::plot_interaction_heatmap(earth.results, view = "juxta.40", clean = TRUE)
mistyR::plot_interaction_heatmap(earth.results, view = "para.120", clean = TRUE)
```

## Signature

### Performance

```{r}
ranger.perf.sig <- mistyR::extract_signature(ranger.results, "performance")
ranger.perf.pca <- stats::prcomp(ranger.perf.sig %>% select(-sample))
```

Color by Grade.

```{r}
ggplot() +
  geom_point(aes(x=ranger.perf.pca$x[,1], y=ranger.perf.pca$x[,2],
                 col=factor(sample.meta$GRADE)))
```

Color by Classification.

```{r}
ggplot() +
  geom_point(aes(x=ranger.perf.pca$x[,1], y=ranger.perf.pca$x[,2],
                 col=factor(sample.meta$Classification)))
```

Color by the log of the tumor.immune ration (see calculation above). This is
basically a measurement of the mixing score (number of immune-tumor interactions divided by the number of immune-immune interactions).

```{r}
ggplot() +
  geom_point(aes(x=ranger.perf.pca$x[,1], 
                 y=ranger.perf.pca$x[,2],
                 col=log10(sample.meta$ratio.tumor.immune))) +
  scale_color_viridis_c()
```

Color by total counts.

```{r}
ggplot() +
  geom_point(aes(x=ranger.perf.pca$x[,1], 
                 y=ranger.perf.pca$x[,2],
                 col=sample.meta$Count.Total)) +
  scale_color_viridis_c()
```

Which factors drive the variance in the results?

```{r}
fviz_pca_var(ranger.perf.pca, col.var="contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
```

### Importance

```{r}
ranger.imp.sig <- mistyR::extract_signature(ranger.results, "importance")
ranger.imp.pca <- stats::prcomp(ranger.imp.sig %>% select(-sample))
```

Color by Grade.

```{r}
ggplot() +
  geom_point(aes(x=ranger.imp.pca$x[,1], y=ranger.imp.pca$x[,2],
                 col=factor(sample.meta$GRADE)))
```

Color by Classification.

```{r}
ggplot() +
  geom_point(aes(x=ranger.imp.pca$x[,1], y=ranger.imp.pca$x[,2],
                 col=factor(sample.meta$Classification)))
```

```{r}
fviz_pca_var(ranger.imp.pca, col.var="contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE)
```

# Save data

```{r}
saveRDS(expr, "data/expression.RDS")
saveRDS(expr.smp, "data/expression_per_sample.RDS")
saveRDS(meta, "data/meta_data.RDS")
saveRDS(sample.meta, "data/sample_meta.RDS")
```

