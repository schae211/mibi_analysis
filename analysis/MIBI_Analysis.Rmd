---
title: "Exploratory Data Analysis MiBi"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
---

# Set up

Messages will be hidden and the output collapsed to make the Rmd more clear.

```{r setup}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, message = FALSE)
knitr::opts_knit$set(root.dir = "~/Saez/workflowr_projects/mibi_analysis/")
```

Loaded Packages.

```{r}
library(mistyR)
library(future)
plan("multisession", workers=14)
library(tidyverse)
```

# Loading and Processing Data

```{r}
input <- read_csv("data/cellData.csv")

# See description in Readme
group.trans <- c("1" = "Unidentified", "2" = "Immune", "3" = "Endothelial", 
                 "4" = "Mesenchymal-like", "5" = "Tumor", 
                 "6" = "Keratin-positive tumor")

immune.group.trans <- c("0" = "Non-Immune?", "1" = "Tregs", "2" = "CD4 T", "3" = "CD8 T", 
                        "4" = "CD3 T", "5" = "NK", "6" = "B",
                        "7" = "Neutrophils", "8" = "Macrophages", 
                        "9" = "DC", "10" = "DC/Mono", "11" = "Mono/Neu", 
                        "12" = "Other immune")

raw_data <- input %>%
  mutate(Group = group.trans[as.character(Group)]) %>%
  mutate(immuneGroup = immune.group.trans[as.character(immuneGroup)])
  
raw_data %>% slice_head(n=6)
```

Add coordinates of the cells.

Doing it in R takes quite some time but offers more control that the 
[center of mass function in scipy](https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.center_of_mass.html)

```{r}
if ("alternative_coordinates.RDS" %in% list.files("data")) {
  alternative.coord <- readRDS("data/alternative_coordinates.RDS")
} else {
  library(tiff)
  lbs <- c(1:29, 31:41)
  alternative.coord <- furrr::future_map_dfr(lbs, function(id) {
    print(id)
    # Read in raw matrix (in tiff format)
    tiff <- readTIFF(paste0("/home/philipp/data/saez/p", id, "_labeledcellData.tiff"),
                     as.is = TRUE)
    seq.rows <- seq_len(nrow(tiff))
    seq.cols <- seq_len(ncol(tiff))
    # important: map over all unique values here! (but I removed 1 and 2)
    cell.ids <- unique(as.vector(tiff))[-which(unique(as.vector(tiff)) %in% c(0,1))]
    map_dfr(cell.ids, function(i) {
      if (i %% 100 == 0) print(i)
      # Convert to binary matrix with TRUE and FALSE
      binary <- (tiff == i)
      s <- sum(binary)
      # Calculate center of mass
      c(id = id, 
        i = i,
        x.center = sum(seq.rows * rowSums(binary)) / s,
        y.center = sum(seq.cols * colSums(binary)) / s
      )
    })
  })
  saveRDS(alternative.coord, file = "data/alternative_coordinates.RDS")
}
```

Join the coordinates with the meta data.

```{r}
data <- raw_data %>%
  inner_join(alternative.coord, by = c("SampleID" = "id", 
                                       "cellLabelInImage" = "i")) %>%
  rename(row = x.center, col = y.center)
```

Diving into sample 40. Let's check which cell IDs where in the tiff 
but not in the meta data. Maybe those spots turned out not be cells 
in the end (segmentation errors?).

```{r}
dplyr::setdiff(
  alternative.coord %>% filter(id == 40) %>% pull(i),
  data %>% filter(SampleID == 40) %>% pull(cellLabelInImage)
  ) %>%
  length()
```

Before proceeding with the analysis, check whether we have any NAs.

```{r}
stopifnot(sum(map_int(colnames(data), ~ sum(is.na(data[[.x]])))) == 0)
```


Split the data into expression matrix and meta data.

```{r}
meta <- data %>%
  select(c(1:3, 53:59))
meta %>% slice_head(n=6)

expr <- data %>%
  select(4:52)
expr %>% slice_head(n=6)
```

# Metadata

Number of cells per sample. Curiously there is not sample 30.

```{r}
meta %>%
  count(SampleID) %>%
  ggplot() +
  geom_bar(aes(x=SampleID, y=n), stat = "identity")
```

Number of "cell types" over all samples as annotated by the authors or the
study. We mostly have tumor and immune cells. Keratin serves as a marker
for cancer cells.

```{r}
meta %>%
  count(Group) %>%
  arrange(desc(n))
```

How were the cells actually classified?

When looking at the first two principal components, we see quite a clear
distinction though the first plot suffers from overplotting. Plotting only
2 percent of the points makes things a little bit better.

```{r}
pca <- stats::prcomp(expr)
ggplot() +
  geom_point(aes(x=seq_len(length(pca$sdev)), y = pca$sdev^2))
ggplot() +
  geom_point(aes(x=pca$x[,1], pca$x[,2], color = meta$Group), size = 0.1)
subs <- sample(nrow(pca$x), .02*nrow(pca$x))
ggplot() +
  geom_point(aes(x=pca$x[subs,1], pca$x[subs,2], 
                 color = meta$Group[subs]), size = 0.1)
```

Cluster the cells using the leiden algorithm? Omitting here, because
it is computiationally quite expensive.

```{r eval=FALSE}
nn <- RANN::nn2(expr, k = 50)
leiden.clusts <- leiden::leiden(nn)
```

Next we will have a closer look at the immune populations. And according
to the number of cells present, macrophages and T-cells are the major
players, followed by B-cells.

```{r}
meta %>%
  count(immuneGroup) %>%
  arrange(desc(n))
```

# Distribution of the markers

Histograms per marker over all samples. We can see that that there is a huge
variability in the expression of different markers. The measured entities 
other than proteins (Au, Background, Beta catentin, C, Ca, Fe, Si, Ta) were
later excluded from the analysis with MISTy.

```{r fig.height=12, fig.width=18}
expr %>%
  pivot_longer(cols = everything(), names_to = "marker", values_to = "expression") %>%
  ggplot() +
  geom_histogram(aes(x=expression), bins = 100) +
  facet_wrap(~ marker, scales = "free")
```

The same plot with a log10 x-axis (thus all 0 value were removed) 
and no free scales.

```{r fig.height=12, fig.width=18}
expr %>%
  pivot_longer(cols = everything(), names_to = "marker", values_to = "expression") %>%
  ggplot() +
  geom_histogram(aes(x=expression), bins = 100) +
  facet_wrap(~ marker) +
  scale_x_log10()
```

Looking at the boxplot for the expression per marker over all samples, ignoring
outliers which are defined as points which includes all points outside of 
median Â± 1.5 * IQR (interquantile range), we can again the broad variablity.

```{r}
expr %>%
  pivot_longer(cols = everything(), names_to = "marker", values_to = "expression") %>%
  ggplot() +
  geom_boxplot(aes(y=expression, x=marker), outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
  coord_cartesian(ylim = c(-5, 5))
```

# Spatial Data

We will first look at the spatial data from all samples in one plot. The
cell types are annotated according to the information the authors of the 
original study provided.

As pointed out in their publication, one can see that there is a continuum 
between mixing of immune cells (yellow) and cancer tissue (green and blue).
Either we can see a clear interface between both populations or they are
totally mixed. This is actually associated with the clinical outcome.

In principle I could stratify the samples based on this phenotype (using
the same mixing score which was used in the paper, namely dividing the number
of immune-tumor interactions (direct neighbors?) by the number of immune-immune
interactions.

```{r fig.height=12, fig.width=18}
meta %>%
  ggplot() +
  geom_point(aes(x = row, y = col, col = Group), size = .1) +
  facet_wrap(~ SampleID) + 
  guides(colour = guide_legend(override.aes = list(size = 4)))
```

## Mixing Score

Calculating the mixing score.

```{r}
coord.type.smp <- unique(meta$SampleID) %>%
  set_names(paste0("s", .)) %>%
  map(function(id) {
    meta %>%
      filter(meta$SampleID == id) %>% 
      select(row, col, Group) %>%
      mutate(Group = ifelse(Group == "Keratin-positive tumor", 
                            "Tumor", Group)) %>%
      filter(Group %in% c("Tumor", "Immune")) %>%
      mutate(id = seq_len(nrow(.)))
  })

# helper function for getting direct neighbors
get_neighbors <- function(ddobj, id) {
  dplyr::union(
    ddobj$delsgs$ind1[which(ddobj$delsgs$ind2 == id)],
    ddobj$delsgs$ind2[which(ddobj$delsgs$ind1 == id)]
  )
}

neighbor.thr <- 40

contacts.smp <- coord.type.smp %>%
  set_names() %>%
  map_dfr(function(smp) {
    
    delaunay <- deldir::deldir(as.data.frame(smp %>% select(row, col)))
    dists <- distances::distances(as.data.frame(smp %>% select(row, col)))
    ids.to.map <- smp %>% filter(Group == "Immune") %>% pull(id)
    
    map(ids.to.map, function(i) {
      alln <- get_neighbors(delaunay, i)
      actualn <- alln[which(dists[alln, i] <= neighbor.thr)]
      
      smp %>%
        filter(id %in% actualn) %>%
        pull(Group)
      
    }) %>% 
      unlist %>%
      table
  })

contacts.smp %>%
  mutate(sample = factor(names(coord.type.smp), 
                         levels = names(coord.type.smp))) %>%
  mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
  ggplot() +
  geom_bar(aes(x=sample, y=ratio.tumor.immune), stat="identity") +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 

contacts.smp %>%
  mutate(sample = names(coord.type.smp)) %>%
  mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
  arrange(desc(ratio.tumor.immune)) %>%
  slice_max(ratio.tumor.immune, n=6)

contacts.smp %>%
  mutate(sample = names(coord.type.smp)) %>%
  mutate(ratio.tumor.immune = Tumor/Immune * 100) %>%
  arrange(desc(ratio.tumor.immune)) %>%
  slice_min(ratio.tumor.immune, n=6)
```

And we can see that those mixing scores resemble exactly what we see
in the visualization.

## Close up sample 40

Looking more closely at sample 40 to make sure that the preprocessing
went right. First, we will look at the cells only using their
calculated center of mass.

```{r fig.height=6, fig.width=8}
meta %>%
  filter(SampleID == 40) %>%
  ggplot() +
  geom_point(aes(x = row, y = col, col = Group), size=.4)
```

And furthermore, we will look at the tiff to.

```{r fig.height=6, fig.width=8}
library(tiff)
id = 40
tiff <- readTIFF(paste0("data/raw_tiffs/p", 
                        id, "_labeledcellData.tiff"), as.is = TRUE)
```

First, the binary tiff, meaning all values that there not 0 or 1 (i.e. a
cell was detected).

```{r}
# get coordinates for where there was a cell detected (=: binary)
binary <- apply(tiff, c(1,2), function(n) !(n %in% c(0,1)))
binary.df <- as.data.frame(binary)
rownames(binary.df) <- seq_len(nrow(binary))
colnames(binary.df) <- seq_len(ncol(binary))

df <- binary.df %>% 
  rownames_to_column(var = "row") %>%
  pivot_longer(cols = !(row), names_to = "col") %>%
  mutate(row = as.numeric(row), col = as.numeric(col))

df %>%
  ggplot() +
  geom_point(aes(x=row, y=col, col=value), size=.1) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank())
```

Second, we will visualize the tiff and the labeled center of mass together.
And on this scale the result actually looks quite nice.

```{r fig.height=8, fig.width=10}
s.40 <- meta %>%
  filter(SampleID == 40)

tiff.40 <- df %>%
  filter(value) %>%
  slice_sample(., n = nrow(.)/10)

ggplot() +
  geom_point(data = tiff.40, aes(x=row, y=col), col="black", 
             size = 0.1, stroke = 0, shape = 16) +
  geom_point(data = s.40, aes(x=row, y=col, col=Group), size = 1) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank())
```

To qualitatively assess the performance of the segmentation we will furthermore
look at a close up of sample 40, more specifically the region from row 0 to
row 600 and from col 1448 to col 2048. And we can see
that the center of mass (colored point) mostly matches the cell boundaries,
but not always! Moreover, in a second plot the cell ids were plotted.

```{r fig.height=8, fig.width=10}
c.max <- dim(binary)[1]
top_left <- list(row = 0, col = c.max)
bottom_right <- list(row = 600, col = c.max-600)

# get the unique coordinates for each cell
tiff.df <- as.data.frame(tiff)
rownames(tiff.df) <- seq_len(nrow(tiff))
colnames(tiff.df) <- seq_len(ncol(tiff))

tiff.df.plot <- tiff.df %>%
  rownames_to_column(var = "row") %>%
  pivot_longer(cols = !(row), names_to = "col") %>%
  mutate(row = as.numeric(row), col = as.numeric(col)) %>%
  filter(!(value %in% c(0, 1))) %>%
  # how to get only entry for each unique value
  group_by(value) %>%
  filter(row_number()==1) %>%
  ungroup()

s.40 <- meta %>%
  filter(SampleID == 40) %>%
  filter(row >= top_left$row, row <= bottom_right$row,
         col >= bottom_right$col, col <= top_left$col)

tiff.40 <- df %>%
  filter(value) %>%
  filter(row >= top_left$row, row <= bottom_right$row,
         col >= bottom_right$col, col <= top_left$col)

labels.40 <- tiff.df.plot %>%
  filter(row >= top_left$row, row <= bottom_right$row,
         col >= bottom_right$col, col <= top_left$col)

ggplot() +
  geom_point(data = tiff.40, aes(x=row, y=col), col="black", 
             size = 0.1, stroke = 0, shape = 16) +
  geom_point(data = s.40, aes(x=row, y=col, col=Group), size = 3) +
  theme(
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank())

ggplot(labels.40) +
  geom_label(aes(x = row, y = col, label = value), size = 2.5)
```



# Run MISTy on all samples

## Preparation

Select only proteins from the expression matrix and check for NAs.

```{r}
expr.smp <- unique(meta$SampleID) %>%
  set_names(paste0("s", .)) %>%
  map(function(id) {
    ret.expr <- expr %>%
      filter(meta$SampleID == id) %>%
      # Select only proteins
      select(11:47)
      
    colnames(ret.expr) <- make.names(colnames(ret.expr))
    ret.expr
  })

sum(map_int(names(expr.smp$s40), ~ sum(is.na(expr.smp$s40[.x]))))

coord.smp <- unique(meta$SampleID) %>%
  set_names(paste0("s", .)) %>%
  map(function(id) {
    meta %>%
      filter(meta$SampleID == id) %>% 
      select(row, col)
  })

sum(map_int(names(coord.smp$s40), ~ sum(is.na(coord.smp$s40[.x]))))

nrow(expr.smp$s40) == nrow(coord.smp$s40)
```

Looking at the pairwise distances to get a feeling for which numbers to 
plug in for generating the juxtaview and paraview.

```{r}
# helper function for nearest neighbors
dist_k_nn <- function(sample, k) {
  nn <- RANN::nn2(sample, eps=0.0, k = k)
  map_dbl(seq_len(nrow(sample)), function(n) {
    mean(nn$nn.dists[n, ])
  })
}

# helper function for getting direct neighbors
get_neighbors <- function(ddobj, id) {
  dplyr::union(
    ddobj$delsgs$ind1[which(ddobj$delsgs$ind2 == id)],
    ddobj$delsgs$ind2[which(ddobj$delsgs$ind1 == id)]
  )
}

# mean distance to the direct neighbors for each cell
mean.dists.direct.neighbors <- map(coord.smp, function(smp) {
  delaunay <- deldir::deldir(as.data.frame(smp))
  dists <- distances::distances(as.data.frame(smp))
  map_dbl(seq_len(nrow(smp)), function(id) {
    nn <- get_neighbors(delaunay, id)
    mean(dists[nn, id])
  })
}) %>% unlist

# histogram
ggplot(data.frame(dist = mean.dists.direct.neighbors)) +
  geom_histogram(aes(dist), bins = 100) +
  lims(x = c(0,100))

# summary
summary(mean.dists.direct.neighbors)

# mean distances to the 5, 10, 15, 20 nearest neighbors
neighbor.dists <- map_dfr(coord.smp, function(smp) {
  c(10, 20, 40, 80) %>%
    set_names() %>%
    map_dfc(function(k) {
  dist_k_nn(smp, k)
    }) %>%
  set_names(paste0("dist_to_", c("10", "20", "40", "80")))
})

# summary
summary(neighbor.dists)

# visualize distribution
neighbor.dists %>%
  pivot_longer(cols = everything()) %>%
  mutate(name = factor(name, levels = paste0("dist_to_", c("10", "20", "40", "80")))) %>%
  ggplot() +
  geom_histogram(aes(value), bins = 100) +
  facet_wrap(~ name) +
  lims(x = c(0, 200))
```

## Generating the MISTy views

Based on the data above, I am ging to use a neighbor threshold of 40 for
the juxtaview and a cutoff of 120 for the paraview (plus the zone of
indifference which will conclusively be 40).

```{r}
if ("misty_views_smp.RDS" %in% list.files("data")) {
  misty.views.smp <- readRDS("data/misty_views_smp.RDS")
} else {
  cv.folds = 10
  misty.views.smp <- map2(expr.smp, coord.smp, function(expr, coord) {
    
    # Check for zero variance (otherwise MISTy throws an error)
    target.var <- apply(expr, 2, stats::sd, na.rm = TRUE)
    expr <- expr %>% select(-names(which(target.var == 0)))
    
    # Check for how many unique values
    target.unique <- colnames(expr) %>%
      purrr::set_names() %>%
      purrr::map_int(~ length(unique(expr %>% pull(.x))))
    expr <- expr %>% select(names(target.unique[target.unique > cv.folds]))
    
    # Create views and run MISTy
    create_initial_view(expr) %>%
      add_juxtaview(positions = coord, neighbor.thr = 40) %>%
      add_paraview(positions = coord, l = 120, zoi = 40)
  })
  names(misty.views.smp) <- names(expr.smp)
  saveRDS(misty.views.smp, "data/misty_views_smp.RDS")
}
```

```{r}
if ("misty_results_smp.RDS" %in% list.files("data")) {
  results.smp <- readRDS("data/misty_results_smp.RDS")
} else {
  cv.folds = 10
  results.smp <- misty.views.smp %>%
    set_names() %>%
    map(function(smp) {
      smp %>%
        run_misty(cv.folds = cv.folds) %>%
        collect_results()
    })
  names(results.smp) <- names(expr.smp)
  saveRDS(results.smp, "data/misty_results_smp.RDS")
}
```

```{r}
source("code/custom_plotting.R")
```

Checking whether things worked (for sample 1).

```{r fig.height=14, fig.width=20}
plot_diagnostics(results.smp$s1, name="s1", low = 0.5)
```

```{r}
if ("misty_results_earth_smp.RDS" %in% list.files("data")) {
  earth.results.smp <- readRDS("data/misty_results_earth_smp.RDS")
} else {
  cv.folds = 10
  earth.results.smp <- misty.views.smp %>%
    set_names() %>%
    map(function(smp) {
      smp %>%
        run_misty(cv.folds = cv.folds, 
                  method = "bag", 
                  learner = "earth",
                  n.learners = 100) %>%
        collect_results()
    })
  names(earth.results.smp) <- names(expr.smp)
  saveRDS(earth.results.smp, "data/misty_results_earth_smp.RDS")
}
```

Checking whether things worked (for sample 1).

```{r fig.height=14, fig.width=20}
plot_diagnostics(earth.results.smp$s1, name="s1")
```

# Aggregating results

## Ranger Gain R2

```{r}
targets <- unique(results.smp$s1$improvements$target)

ranger.measures <- map_dfr(targets, function(tar) {
  map2_dfr(results.smp, names(results.smp), function(smp, n) {
    smp$improvements %>%
      filter(target == tar) %>%
      filter(measure %in% c("intra.R2", "multi.R2", "gain.R2")) %>%
      mutate(sample = n)
  })
})
```

```{r}
ranger.measures %>%
  filter(measure == "gain.R2") %>%
  group_by(target) %>%
  summarise(mean.gain = mean(value)) %>%
  ggplot() +
  geom_bar(aes(x = target, y = mean.gain), stat="identity") +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 

ranger.measures %>%
  filter(measure == "gain.R2") %>%
  ggplot() +
  geom_boxplot(aes(x = target, y = value)) +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 
```

## Earth R2 gain

```{r}
earth.measures <- map_dfr(targets, function(tar) {
  map2_dfr(earth.results.smp, names(earth.results.smp), function(smp, n) {
    smp$improvements %>%
      filter(target == tar) %>%
      filter(measure %in% c("intra.R2", "multi.R2", "gain.R2")) %>%
      mutate(sample = n)
  })
})
```

```{r}
earth.measures %>%
  filter(measure == "gain.R2") %>%
  group_by(target) %>%
  summarise(mean.gain = mean(value)) %>%
  ggplot() +
  geom_bar(aes(x = target, y = mean.gain), stat="identity") +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 

earth.measures %>%
  filter(measure == "gain.R2") %>%
  ggplot() +
  geom_boxplot(aes(x = target, y = value)) +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 
```

## Comparison of Ranger and Earth results

### Multi R2

```{r fig.width=8, fig.height=8}
tmp1 <- ranger.measures %>% mutate(method = "ranger")
tmp2 <- earth.measures %>% mutate(method = "earth")
all <- rbind(tmp1, tmp2)
all %>%
  filter(measure == "multi.R2") %>%
  ggplot() +
  geom_boxplot(aes(x=target, y=value)) +
  facet_wrap(~ method, nrow=2) +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1)) 
```

### Gain R2

```{r fig.width=10, fig.height=6}
m <- "gain.R2"
all %>%
  mutate(new_target = paste0(target, "_", method)) %>%
  filter(measure == m) %>%
  ggplot() +
  geom_boxplot(aes(x=new_target, y=value, col=method)) +
  labs(title = m) +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1),
        plot.title = element_text(hjust = 0.5))
```

### Multi R2

```{r fig.width=10, fig.height=6}
m <- "multi.R2"
all %>%
  mutate(new_target = paste0(target, "_", method)) %>%
  filter(measure == m) %>%
  ggplot() +
  geom_boxplot(aes(x=new_target, y=value, col=method)) +
  labs(title = m) +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1),
        plot.title = element_text(hjust = 0.5))
```

### Intra R2

```{r fig.width=10, fig.height=6}
m <- "intra.R2"
all %>%
  mutate(new_target = paste0(target, "_", method)) %>%
  filter(measure == m) %>%
  ggplot() +
  geom_boxplot(aes(x=new_target, y=value, col=method)) +
  labs(title = m) +
  theme(axis.text.x = ggplot2::element_text(angle = 90, hjust = 1),
        plot.title = element_text(hjust = 0.5))
```



